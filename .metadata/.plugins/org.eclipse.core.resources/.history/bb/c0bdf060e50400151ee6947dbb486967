package andrew.deng.multithreading.forkjoinpooltest;

import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

public class FirstTest {

	private static int[] list = new int[10000];


	public static void main(String[] args) {
		// TODO Auto-generated method stub
		for (int i = 0; i < 10000; i++) {
			list[i] = i;
		}
		
		FirstTest f=new FirstTest();F
		f.parallelSum(list);

	}

	public static  int parallelSum(int[] list) {
		RecursiveTask<Integer> task = new ParallelSum(list);
		ForkJoinPool pool = new ForkJoinPool();
		return pool.invoke(task);

	}

	class ParallelSum extends RecursiveTask {
		private int list[];
		private final int THOLD = 1000;

		public ParallelSum(int[] list) {
			super();
			this.list = list;
		}

		@Override
		protected Integer compute() {
			if (list.length < THOLD) {
				int sum = 0;
				for (int i = 0; i < THOLD; i++) {
					sum = sum + list[i];
				}

				return new Integer(sum);

			} else {

				int[] leftList = new int[list.length / 2];
				int[] rightList = new int[list.length / 2];
				System.arraycopy(list, 0, leftList, 0, list.length / 2);
				System.arraycopy(list, list.length / 2, rightList, 0,
						list.length / 2);
				RecursiveTask<Integer> leftTask = new ParallelSum(leftList);
				RecursiveTask<Integer> rightTask = new ParallelSum(rightList);

				rightTask.fork();
				leftTask.fork();

				int leftResult = leftTask.join().intValue();
				int rightResult = rightTask.join().intValue();

				System.out.println("result: " + leftResult + rightResult);
				return leftResult + rightResult;
			}

		}

	}

}
